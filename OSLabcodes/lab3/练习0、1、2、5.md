## 练习零 ##
本实验依赖实验2。请把你做的实验2的代码填入本实验中代码中有“LAB2”的注释相应部分。（建议手动补充，不要直接使用merge）<br><br>
详细内容见LAB2，这里不再对这部分内容进行详细解释。
## 练习一 ##
<strong>问题：</strong>
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了kern/mm/swap_fifo.c文件中，这点请同学们注意）

至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数<br><br>

<strong>解答：</strong>
FIFO页面置换算法是本次实验中最简单的页面置换算法，其实现的主要原理是操作系统按照页进入物理内存的顺序进行页面的替换。当发生缺页异常且没有空闲物理页框可供使用时，FIFO算法选择最早进入内存的页面进行替换。在本次实验中框架代码使用了一个队列来维护页面进入内存的顺序，当页面被载入内存时向队列尾部加一个新页面，当发生一次缺页异常时从队首替换掉一个新页面。<br>
我们认为一个页面从换入到换出的过程中主要经过了如下函数与宏的处理：<br><br>
_<code>fifo_init_mm(struct mm_struct *mm)</code><br>
该函数的作用是初始化 FIFO 算法，用于管理所有可以被换出的页面。它通过调用 `list_init` 来设置 FIFO 队列，并将 `mm->sm_priv` 指向 `pra_list_head`，以便关联到页面替换链表。

<code>_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)</code><br>
该函数将所需的页面附加到 `pra_list_head` 的末尾，表示这是最近加载到内存的页面。通过调用 `list_add`，页面被添加到队列的尾部。

<code>_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)</code><br>
根据 FIFO 算法，从队列的前端提取最早加载到内存的页面。通过 `list_prev` 获取队列中最早的页面，随后使用 `list_del` 将其从队列中移除，并将该页面的地址存储到 `ptr_page` 指针中。

<code>_fifo_check_swap()</code><br> 一个测试函数通过多次对不同内存地址的写入操作，模拟了页面置换的多次执行，并再现了缺页异常的处理过程。<br><br>

我们认为框架代码的页面置换流程大致如下，其中包含有不少于十个函数的具体功能：<br>
<strong>页面换入（swap\_in）:</strong><br>
功能：从磁盘换入页面到内存。<br>
实现步骤：<br>
调用 alloc\_page 申请一块连续的内存空间。<br>
使用 get\_pte 查找或构建页面的对应页表项。<br>
调用 swapfs\_read 将页面数据从磁盘加载到内存。<br>

<strong>页面申请（alloc\_page）:</strong><br>
功能：为页面分配内存空间。<br>
实现步骤：<br>
通过 pmm\_manager->alloc\_pages 申请一块连续的内存。<br>
如果申请失败，调用 swap\_out 换出页面以腾出空间，然后重试页面分配。<br>
使用 assert(result != NULL) 确保页面分配成功。<br>

<strong>页面换出（swap\_out）:</strong><br>
功能：将内存中的页面写回磁盘以释放空间。<br>
实现步骤：<br>
循环调用 sm->swap\_out\_victim 找到需要换出的页面（对应 FIFO 算法中 \_fifo\_swap\_out\_victim）。<br>
使用 get\_pte 获取对应的页表项。<br>
调用 swapfs\_write 将页面数据写回磁盘。<br>
如果写入成功，则调用 free\_page 释放页面。<br>
如果写入失败，调用 \_fifo\_map\_swappable 将页面重新加入队列。<br>
调用 tlb\_invalidate 刷新 TLB。<br>

<strong>页面释放（free\_page）:</strong><br>
功能：释放页面占用的内存。<br>
实现步骤：<br>
调用 pmm\_manager->free\_pages 释放页面资源。<br>
使用 assert((*ptep & PTE\_V) != 0) 检查页表项是否合法。<br>

<strong>磁盘与内存的读写:</strong><br>
swapfs\_write：将页面内容写入磁盘。如果页面内容已被修改，与磁盘数据不一致，则必须重新写回磁盘。<br>
swapfs\_read：从磁盘中读取页面数据到内存。<br>

<strong>TLB 刷新（tlb\_invalidate）:</strong><br>
功能：在页表更新后，通过调用 flush\_tlb 刷新 TLB 以确保一致性。
FIFO 算法的关键操作<br>
\_fifo\_swap\_out\_victim：获取需要换出的页面。该操作通常从队列末尾查找最早进入内存的页面。<br>
\_fifo\_map\_swappable：将最近使用的页面移至队头，避免下一次换出时重复失败。<br>


## 练习二 ##
<strong>问题：</strong>get\_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

get\_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get\_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

<strong>解答：</strong>
相似之处在于，这两段代码都用于获取虚拟地址对应的页表项，并在必要时创建新的页和页表项。第一段代码的目标是从 GiGa Page 查找 PDX1 地址，如果地址无效，则为该页表项分配内存空间；第二段代码用于从 MeGa Page 查找 PDX0 地址，同样在地址不合法时为该页表项分配内存。两者的查找逻辑一致，唯一区别在于基地址和页表偏移量所在的位数。而三种页表管理机制的不同仅在于虚拟地址的长度或页表的层级数量，只需按偏移量规则操作，就能定位到目标页表项。

这种写法更好。通常情况下，我们仅在检测到页表项无效时才创建页表，并且关注点仅在最后一级页表所指向的页。这种实现方式整合了逻辑，减少了代码重复、函数调用次数及调用深度，从而使代码更加简洁高效。

## 练习五 ##
<strong>问题：</strong>如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？<br> 
<strong>解答：</strong><br> 
**优势**：减少了内存访问次数，只需一次访问即可获取物理地址；能够映射更大的连续内存空间；降低了 TLB 缺失的可能性；简化了操作系统对页表的管理。<br>  
**劣势**：页表项必须连续存储，占用大量内存空间；使用大页可能导致内部碎片问题；对小内存系统不够友好；可能增加页表维护的复杂性。<br>